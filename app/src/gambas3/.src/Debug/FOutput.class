' Gambas class file

Private $aHistory As New String[]
Private $bGotError As Boolean
Private $iHistory As Integer
Private $sCurrent As String

Private $iLinkY As Integer
Private $iLinkX As Integer
Private $iLinkLen As Integer

'PUBLIC Shown AS Boolean

Public Sub _new()

  'Config.LoadWindow(ME, "/FOutput")
  Settings.Read(Me)
  ReadConfig
  
  chkCharset.Visible = System.Charset <> Desktop.Charset
  sepCharset.Visible = chkCharset.Visible
  btnUndock.Value = Settings["/FOutput/Undock", False]
  btnAbove.Value = Settings["/FOutput/KeepAbove", False]
  btnEcho.Value = Settings["/FOutput/Echo", False]
  OnProjectDebug
  
  edtOutput.Styles[Highlight.Keyword].Underline = True
  edtOutput.Styles[Highlight.Keyword].Bold = False
  edtOutput.Styles[Highlight.Keyword].Foreground = Color.Blue

End

Public Sub GetEditor() As Editor
  
  Return edtOutput
  
End


Public Sub Clear()

  edtOutput.Clear
  txtEnter.Clear
  txtEnter.SetFocus
  $iHistory = $aHistory.Count

End


Public Sub Insert(sText As String, Optional bCurrent As Boolean)

  If chkCharset.Value Then  
    Try sText = DConv$(sText)
  Endif

  If Not bCurrent Then 
    'edtOutput.Line = edtOutput.Lines.Count
    'edtOutput.Goto(edtOutput.Lines.Count, 10000)
  Endif
  
  edtOutput.ReadOnly = False
  edtOutput.Print(sText)
  edtOutput.ReadOnly = True
  
  If Not Action["console"].Value Then Action["console"].Value = True

End

Public Sub ReadConfig()

  edtOutput.ReadConfig
  edtOutput.Font = Font[Settings["/ConsoleFont", Project.DEFAULT_FONT]]

  MTheme.InitEditor(edtOutput)

  edtOutput.Flags[Editor.ShowCurrentLine] = False
  edtOutput.Flags[Editor.ShowModifiedLines] = False
  edtOutput.Flags[Editor.ShowLineNumbers] = False
  edtOutput.Flags[Editor.HideMargin] = True
  
  Project.SetSmallFont(tlbOutput)
  
  txtEnter.Font = edtOutput.Font
  lblEnter.Font = edtOutput.Font
  lblEnter.Font.Bold = True
  panEnter.H = txtEnter.Font.Height + 4

End

Public Sub edtOutput_KeyPress()

  If Key.Code = Key.Escape Then 
  
    Action["console"].Value = False

  Else If Key.Control Then

    If Key.Code = Key["L"] Then
      Clear
    Else If Key.Code = Key["G"] Then 
      edtOutput.ReadOnly = False
      edtOutput.Print(Chr$(7))
      edtOutput.ReadOnly = True
    Endif
    
  Endif

End

Public Sub Form_Close()

  If Not Me.Parent Then 
    'DEBUG "Write: "; ME.X;; ME.Y
    Settings.Write(Me)
  Endif
  'Action["console"].Value = FALSE
  'Settings.Write(ME)

End

Public Sub Form_Show()

  'Action["console"].Value = TRUE

End

Public Sub Form_GotFocus()

  txtEnter.SetFocus

End

Public Sub btnClear_Click()

  Clear

End

Public Sub btnCut_Click()

  edtOutput.Cut

End

Public Sub btnCopy_Click()

  edtOutput.Copy

End

Public Sub btnPaste_Click()

  edtOutput.Paste

End

Public Sub Form_Activate()

  'edtOutput.SetFocus

End

Public Sub btnUndock_Click()

  Settings["/FOutput/Undock"] = btnUndock.Value
  OnProjectDebug
  FDebugInfo.UpdateView

End

' PUBLIC SUB Toggle(bShow AS Boolean)
'   
'   IF NOT btnUndock.Value THEN
'     'IF NOT Project.Running THEN 
'       FMain.ShowDebug(bShow)
'     'ENDIF 
'   ELSE 
'     ME.Visible = bShow
'   ENDIF
'   
' END

Public Sub OnProjectDebug()
  
  btnAbove.Visible = Project.Running And btnUndock.Value
  If btnUndock.Value Then Me.Stacking = If(Project.Running And btnAbove.Value, Window.Above, Window.Normal)
  'panControl.Visible = Project.Running
  
End


Public Sub btnAbove_Click()

  Settings["/FOutput/KeepAbove"] = btnAbove.Value
  OnProjectDebug
  
End

Public Sub Form_Open()

  If Not Me.Parent Then 
    Settings.Read(Me)
    'DEBUG "Read: "; ME.X;; ME.Y
  Endif
  
End

Public Sub edtOutput_Menu()

  mnuEditor.Popup

End

Public Sub btnUndo_Click()
  
  edtOutput.Undo
  
End

Public Sub btnRedo_Click()
  
  edtOutput.Redo
  
End

Public Sub edtOutput_GotFocus()

  Project.SetCurrentPopup(mnuEditor)
  FSearch.Update
  
End

Public Sub txtFind_KeyPress()

  If Key.Code = Key.F3 
    If Key.Normal Then 
      FSearch.FindNext
    Else If Key.Shift Then 
      FSearch.FindPrevious
    Endif
    Stop Event 
  Endif

End

Public Sub edtOutput_LostFocus()

  If Project.AboutToQuit Then Return
  FSearch.Update

End


Public Sub GetText() As String
  
  Return edtOutput.Text
  
End

Public Sub GetPosition() As Integer
  
  Return edtOutput.GetPosition()

End

Public Sub SetPosition(hResult As CFindResult, Optional bJustCheck As Boolean) As Boolean
  
  Return edtOutput.SetPosition(hResult, bJustCheck)
  
End

Public Sub Replace(sReplace As String)
  
  edtOutput.Replace(sReplace)
  
End

Public Sub GetSelection() As String
  
  Return edtOutput.GetSelection()
  
End

Public Sub btnSearch_Click()

  txtEnter.SetFocus
  FSearch.WakeUp(False)

End


' Public Sub btnControl_Click()
' 
'   Design.Send(Chr$(Asc(Right$(Last.Text)) - 64))
' 
' End
' 
' Public Sub btnCtrlD_Click()
' 
'   Print #Design.GetProcess(), Chr$(4);
' 
' End

Public Sub txtEnter_Activate()

  Dim sText As String
  Dim bSemiColon As Boolean
  Dim sVal As String

  sText = txtEnter.Text
  If $iHistory = $aHistory.Count Or If sText <> $aHistory[$iHistory] Then
    $aHistory.Add(txtEnter.Text)
    If $aHistory.Count > 256 Then $aHistory.Remove(0)
  Endif
  $iHistory = $aHistory.Count
  txtEnter.Clear

  If Design.IsRunning() Then

    'edtOutput.Insert("\n")
    If btnEcho.Value Then Insert(sText & "\n")
    Design.Send(sText & "\n")
    'Debug
    Stop Event

  Else

    sText = Trim(sText)
    If Not sText Then Return

    If Project.Running Then

      If btnEcho.Value Then Insert("Print " & sText & "\n")

      'edtOutput.Insert("\n")
      Design.Command("!\t" & sText)
      Stop Event

    Else

      If btnEcho.Value Then Insert("Print " & sText & "\n")

      Try sVal = Str(Eval(sText & "\n"))
      If Error Then
        txtEnter.Text = Error.Text
        txtEnter.Foreground = Color.Red
        $bGotError = True
      Else
        sVal = DConv$(sVal)
        If Not bSemiColon Then sVal &= "\n"
        Insert(sVal)
      Endif
      Stop Event

    Endif

  Endif
  

End

Public Sub txtEnter_KeyPress()

  If $bGotError Then
    $bGotError = False
    txtEnter.Foreground = Color.Default
    txtEnter.Clear
  Endif
  
  If Key.Code = Key.Up Then
    If $iHistory Then
      If $iHistory = $aHistory.Count Then $sCurrent = txtEnter.Text
      Dec $iHistory
      txtEnter.Text = $aHistory[$iHistory]
    Endif
    Stop Event
  Else If Key.Code = Key.Down Then
    If $iHistory < $aHistory.Count Then
      Inc $iHistory
      If $iHistory = $aHistory.Count Then 
        txtEnter.Text = $sCurrent
      Else
        txtEnter.Text = $aHistory[$iHistory]
      Endif
    Endif
    Stop Event
  Else If Key.Code = Key.Home And If Key.Control Then
    edtOutput.Goto(0, 0)
    edtOutput.SetFocus
    Stop Event
  Else
    edtOutput_KeyPress
  Endif

End

Public Sub btnEcho_Click()

  Settings["/FOutput/Echo"] = btnEcho.Value

End

Public Sub edtOutput_Highlight()

  If $iLinkLen = 0 Then Return
  If $iLinkY <> Highlight.Line Then Return

  Highlight.Add(Highlight.Keyword, $iLinkLen)

End

Public Sub edtOutput_MouseMove()

  Dim MX, MY As Integer
  Dim X, Y As Integer
  Dim sText As String
  Dim iPos As Integer
  Dim aScan As String[]
  Dim iNewX As Integer
  Dim iNewY As Integer
  Dim iNewLen As Integer
  
  If Not edtOutput.Hovered Then Return
  
  Try MX = Mouse.X
  If Not Error Then 
    MY = Mouse.Y
  Else
    MX = Mouse.ScreenX - edtOutput.ScreenX
    MY = Mouse.ScreenY - edtOutput.ScreenY
  Endif

  X = edtOutput.PosToColumn(MX, MY)
  Y = edtOutput.PosToLine(MY)
  
  If Y >= 0 And If X >= 0 Then
  
    sText = edtOutput.Lines[Y].Text
    
    iPos = InStr(sText, ": ")
    If iPos Then
      aScan = Scan(Left(sText, iPos - 1), "*.*.*")
      If aScan.Count = 3 And If IsDigit(aScan[2]) Then 
        iNewY = Y
        iNewX = 0
        iNewLen = iPos - 1
      Endif
    Endif
  Endif
  
  If $iLinkLen Then 
    $iLinkLen = 0
    Try edtOutput.Lines[$iLinkY].Refresh
  Endif
  
  If iNewLen Then 
    $iLinkX = iNewX
    $iLinkY = iNewY
    $iLinkLen = iNewLen
    edtOutput.Lines[iNewY].Refresh
  Endif
  
  If $iLinkLen Then 
    edtOutput.Mouse = Mouse.Pointing
  Else
    edtOutput.Mouse = Mouse.Default
  Endif

End

Public Sub edtOutput_Leave()

  If $iLinkLen Then 
    $iLinkLen = 0
    edtOutput.Lines[$iLinkY].Refresh
  Endif
  
End

Public Sub edtOutput_MouseDown()

  If $iLinkLen And If Mouse.Normal Then
    If Not Project.Goto(Left$(edtOutput.Lines[$iLinkY].Text, $iLinkLen)) Then 
      Stop Event
    Endif
  Endif

End


Public Sub edtOutput_Scroll()

  edtOutput_MouseMove

End
